(load "01graph.scm")

; Идеята на вземането на всички ребра:
; 1. Филтрираме върховете, които нямат никакви съседи (т.е. не участват в ребра)
; 2. За всеки от филтрираните върхове намираме всичките му съседи.
; 3. За всеки съсед от стъпка 2 създаваме двойката (връх съсед) и (с map) я 
;    правим част от списък от двойки който има вида ((връх-i съсед-1) 
;    (връх-i съсед-2) ...). Резултатът от тази операция ще са всичките ребра, 
;    които имат за начало избрания на стъпка 2 връх.
; 4. Залепяме списъците, получени на стъпка 3.
(define (edges g)
  ; С apply append „залепяме“ списъците с ребра за всеки връх. Тоест, превръщаме
  ; списък от вида (за върховете 1, 2, 3):
  ; (((1 2) (1 3)) ((2 1) (2 4)) ((3 5))) 
  ; В списък от вида:
  ; ((1 2) (1 3) (2 1) (2 4) (3 5))
  (apply 
    append 
    (map (lambda (vertex)
           ; Създаваме списък от всички ребра с начало vertex.
           (map (lambda (neighbour)
                  ; Добавяме ребро към резултата.
                  (list vertex neighbour))
                (neighbours vertex g)))
         ; Филтрираме върховете, които имат съседи:
         (filter (lambda (vertex)
                   (> (length (neighbours vertex g))
                      0))
                 (vertices g)))))

(define g1 (create-graph '(5 7)))
(add-vertex! 1 g1)
(add-vertex! 2 g1)
(add-vertex! 4 g1)
(add-edge! 1 2 g1)
(add-edge! 1 4 g1)
(add-edge! 5 2 g1)
(assert-equal '((5 2) (1 4) (1 2)) (edges g1))
